# SOLID

S   => SRP => Single Responsibility Principle
Uma classe deve ter apenas um, e apenas um,  motivo para ser modificada.
O	=> OCP => Open / Closed Principle
Entidas de Software (classes, módulos, funções, etc) devem estar abertas para extensão 
e fechadas para modificação 
L	=> LSP => Liskov Substitution Principle
Se q(x) é uma propriedade demonstrável dos objetos x do tipo T. Então q(y) deve ser verdadeiro para objetos y de tipo S, onde S é um subtipo de T.
I	=> ISP => Interface Segregation Principle
Muitas interfaces específicas são melhores do que uma interface única.
O ISP ajuda quando uma determinada interface se torna “gorda” ou genérica demais com muitas responsabilidades e aplicando esse padrão, podemos subdividir essa interface em partes menores com responsabilidades mais específicas (assim fazendo valer seu mantra).
D	=> DIP => Dependency Inversion Principle
Módulos de alto nível não devem depender de módulos de nível inferior.
Ambos devem depender de abstrações

Abstrações não podem depender dos detalhes.

Detalhes (implementações concretas) devem depender de abstrações.





# Créditos
Exemplo retirado da aula abaixo:
Confira o artigo e o vídeo explicativo neste artigo:
<a href="http://eduardopires.net.br/2015/01/solid-teoria-e-pratica/" target="_blank">SOLID – Teoria e Prática</a>
